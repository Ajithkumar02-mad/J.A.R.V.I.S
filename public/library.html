<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>J.A.R.V.I.S â€“ Library</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- HEADER -->
  <header>
    <div class="logo"><a href="index.html">J.A.R.V.I.S</a></div>
    <div class="hud-clock-wrapper">
  <div class="hud-clock" id="hud-clock">--:--:--</div>
  <div class="hud-date">
    <div id="hud-date">--.--.----</div>
    <div id="hud-day">----</div>
  </div>
</div>

    <div class="status">
      <span class="status-dot"></span>
      Library module Â· Your PDF archive, Ajith
    </div>
  </header>

  <div class="page-wrap">
    <div class="page-inner">
      <!-- top click closes back to HUD -->
      <div class="panel-header" onclick="closePanel()">â—‰ LIBRARY MODULE</div>

      <div class="card">
        <div class="section-title">LIBRARY</div>
        <div class="section-subtitle">
          Import your PDF books directly and organize them into shelves and folders.
        </div>

        <div class="library-layout">
          <!-- LEFT: SHELVES -->
          <aside class="library-shelves">
            <div class="card-inner-title">SHELVES</div>
            <div class="section-subtitle">Choose a shelf.</div>

            <div id="shelf-list" class="shelf-list"></div>

            <button class="primary" id="add-shelf-btn" type="button">
              + ADD SHELF
            </button>
          </aside>

          <!-- RIGHT: FOLDERS + BOOKS -->
          <section class="library-main">
            <div class="library-toolbar">
              <div class="pill" id="current-shelf-label">
                Shelf: All Books
              </div>
              <div class="pill" id="current-folder-label">
                Folder: All Folders
              </div>

              <div class="toolbar-actions">
                <button class="primary" id="add-folder-btn" type="button">
                  + ADD FOLDER
                </button>
                <button class="primary" id="add-book-btn" type="button">
                  + ADD PDF
                </button>
                <input
                  type="file"
                  id="add-pdf-input"
                  accept="application/pdf"
                  multiple
                  style="display: none;"
                />
              </div>
            </div>

            <div class="divider"></div>

            <!-- FOLDER CHIPS ROW -->
            <div class="folder-row">
              <div class="folder-row-title">FOLDERS</div>
              <div id="folder-chips" class="folder-chips"></div>
            </div>

            <div class="divider subtle"></div>

            <!-- BOOKS LIST -->
            <div id="book-list" class="book-list"></div>
            <div id="library-empty-state" class="library-empty-state">
              No PDFs in this view yet.<br />
              Select a shelf and folder, then use <strong>+ Add PDF</strong>.
            </div>
          </section>
        </div>
      </div>

      <!-- Shelf options dropdown (3 dots menu) -->
      <div id="shelf-menu" class="shelf-menu">
        <button type="button" data-action="organise">Organise</button>
        <button type="button" data-action="delete">Delete</button>
      </div>

      <!-- Folder options dropdown (3 dots menu) -->
      <div id="folder-menu" class="folder-menu">
        <button type="button" data-action="rename">Rename</button>
        <button type="button" data-action="delete">Delete</button>
      </div>
    </div>
  </div>

  <script src="sounds.js"></script>


  <script>
    /* ---------- CLOCK ---------- */
   let lastDateKey = null;

function updateClock() {
  const timeEl = document.getElementById("hud-clock");
  const dateEl = document.getElementById("hud-date");
  const dayEl  = document.getElementById("hud-day");
  const dateWrap = document.querySelector(".hud-date");

  if (!timeEl || !dateEl || !dayEl || !dateWrap) return;

  const now = new Date();

  /* ---------- TIME ---------- */
  const h = String(now.getHours()).padStart(2, "0");
  const m = String(now.getMinutes()).padStart(2, "0");
  const s = String(now.getSeconds()).padStart(2, "0");
  timeEl.textContent = `${h}:${m}:${s}`;

  /* ---------- DATE ---------- */
  const dd = String(now.getDate()).padStart(2, "0");
  const mm = String(now.getMonth() + 1).padStart(2, "0");
  const yyyy = now.getFullYear();
  const todayKey = `${dd}-${mm}-${yyyy}`;

  /* ---------- MIDNIGHT FADE ---------- */
  if (lastDateKey && lastDateKey !== todayKey) {
    dateWrap.classList.remove("show");
    dateWrap.classList.add("fade");

    setTimeout(() => {
      dateEl.textContent = todayKey;
      dayEl.textContent = now.toLocaleDateString(undefined, { weekday: "long" });
      dateWrap.classList.remove("fade");
      dateWrap.classList.add("show");
    }, 600);
  } else {
    dateEl.textContent = todayKey;
    dayEl.textContent = now.toLocaleDateString(undefined, { weekday: "long" });
    dateWrap.classList.add("show");
  }

  lastDateKey = todayKey;

  /* ---------- WEEKEND COLOR LOGIC ---------- */
  dateWrap.classList.remove("weekday", "saturday", "sunday");

  const day = now.getDay(); // 0 = Sunday, 6 = Saturday
  if (day === 0) {
    dateWrap.classList.add("sunday");
  } else if (day === 6) {
    dateWrap.classList.add("saturday");
  } else {
    dateWrap.classList.add("weekday");
  }
}
    updateClock();
    setInterval(updateClock, 1000);

  /* ---------- CLOSE PANEL BACK TO HUD ---------- */
  function closePanel() {
  playJarvisSound("panelClose");

  const card = document.querySelector(".card");
  if (card) {
    card.style.transform = "scale(0.92)";
    card.style.opacity = "0";
    card.style.transition = "0.25s ease";
  }

  // â±ï¸ Wait for sound + animation
  setTimeout(() => {
    window.location.href = "index.html";
  }, 350); // ðŸ‘ˆ IMPORTANT
}

    /* ---------- LIBRARY DB ---------- */

    const DB_NAME = "jarvisLibraryV2";
    const DB_VERSION = 1;
    const SHELF_STORE = "shelves";
    const FOLDER_STORE = "folders";
    const BOOK_STORE = "books";

    let db = null;
    let currentShelfId = "all";
    let currentFolderId = "all";

    async function openLibraryDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = () => {
          const db = request.result;

          if (!db.objectStoreNames.contains(SHELF_STORE)) {
            db.createObjectStore(SHELF_STORE, {
              keyPath: "id",
              autoIncrement: true
            });
          }

          if (!db.objectStoreNames.contains(FOLDER_STORE)) {
            const folderStore = db.createObjectStore(FOLDER_STORE, {
              keyPath: "id",
              autoIncrement: true
            });
            folderStore.createIndex("shelfId", "shelfId", { unique: false });
          }

          if (!db.objectStoreNames.contains(BOOK_STORE)) {
            const bookStore = db.createObjectStore(BOOK_STORE, {
              keyPath: "id",
              autoIncrement: true
            });
            bookStore.createIndex("folderId", "folderId", { unique: false });
          }
        };

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function ensureDefaultShelfAndFolder() {
      const tx = db.transaction(SHELF_STORE, "readwrite");
      const store = tx.objectStore(SHELF_STORE);

      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = async () => {
          const shelves = req.result || [];
          if (shelves.length === 0) {
            const addReq = store.add({ name: "General", createdAt: Date.now() });
            addReq.onsuccess = async () => {
              const shelfId = addReq.result;
              await addFolder("Main", shelfId);
              resolve();
            };
            addReq.onerror = () => reject(addReq.error);
          } else {
            resolve();
          }
        };
        req.onerror = () => reject(req.error);
      });
    }

    /* ---------- CRUD HELPERS ---------- */

    async function getShelves() {
      const tx = db.transaction(SHELF_STORE, "readonly");
      const store = tx.objectStore(SHELF_STORE);
      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }

    async function addShelf(name) {
      const tx = db.transaction(SHELF_STORE, "readwrite");
      const store = tx.objectStore(SHELF_STORE);
      return new Promise((resolve, reject) => {
        const req = store.add({ name, createdAt: Date.now() });
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function renameShelf(id, newName) {
      const tx = db.transaction(SHELF_STORE, "readwrite");
      const store = tx.objectStore(SHELF_STORE);
      return new Promise((resolve, reject) => {
        const getReq = store.get(id);
        getReq.onsuccess = () => {
          const shelf = getReq.result;
          if (!shelf) { resolve(); return; }
          shelf.name = newName;
          const putReq = store.put(shelf);
          putReq.onsuccess = () => resolve();
          putReq.onerror = () => reject(putReq.error);
        };
        getReq.onerror = () => reject(getReq.error);
      });
    }

    async function getFoldersForShelf(shelfId) {
      const tx = db.transaction(FOLDER_STORE, "readonly");
      const store = tx.objectStore(FOLDER_STORE);
      const index = store.index("shelfId");
      return new Promise((resolve, reject) => {
        const req = index.getAll(Number(shelfId));
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }

    async function getAllFolders() {
      const tx = db.transaction(FOLDER_STORE, "readonly");
      const store = tx.objectStore(FOLDER_STORE);
      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }

    async function addFolder(name, shelfId) {
      const tx = db.transaction(FOLDER_STORE, "readwrite");
      const store = tx.objectStore(FOLDER_STORE);
      return new Promise((resolve, reject) => {
        const req = store.add({
          name,
          shelfId: Number(shelfId),
          createdAt: Date.now()
        });
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function renameFolder(folderId, newName) {
      const tx = db.transaction(FOLDER_STORE, "readwrite");
      const store = tx.objectStore(FOLDER_STORE);
      return new Promise((resolve, reject) => {
        const getReq = store.get(Number(folderId));
        getReq.onsuccess = () => {
          const folder = getReq.result;
          if (!folder) { resolve(); return; }
          folder.name = newName;
          const putReq = store.put(folder);
          putReq.onsuccess = () => resolve();
          putReq.onerror = () => reject(putReq.error);
        };
        getReq.onerror = () => reject(getReq.error);
      });
    }

    async function deleteFolderAndBooks(folderId) {
      const tx1 = db.transaction(BOOK_STORE, "readwrite");
      const store1 = tx1.objectStore(BOOK_STORE);
      const index = store1.index("folderId");
      await new Promise((resolve, reject) => {
        const range = IDBKeyRange.only(Number(folderId));
        const req = index.openCursor(range);
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            cursor.delete();
            cursor.continue();
          } else { resolve(); }
        };
        req.onerror = () => reject(req.error);
      });

      const tx2 = db.transaction(FOLDER_STORE, "readwrite");
      const store2 = tx2.objectStore(FOLDER_STORE);
      await new Promise((resolve, reject) => {
        const req = store2.delete(Number(folderId));
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function deleteShelfAndContents(id) {
      const folders = await getFoldersForShelf(id);
      for (const folder of folders) {
        await deleteFolderAndBooks(folder.id);
      }
      const tx = db.transaction(SHELF_STORE, "readwrite");
      const store = tx.objectStore(SHELF_STORE);
      await new Promise((resolve, reject) => {
        const req = store.delete(Number(id));
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function getAllBooks() {
      const tx = db.transaction(BOOK_STORE, "readonly");
      const store = tx.objectStore(BOOK_STORE);
      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }

    async function addBookRecord(file, folderId) {
      const tx = db.transaction(BOOK_STORE, "readwrite");
      const store = tx.objectStore(BOOK_STORE);
      const record = {
        name: file.name,
        folderId: Number(folderId),
        size: file.size,
        type: file.type,
        addedAt: Date.now(),
        fileBlob: file
      };
      return new Promise((resolve, reject) => {
        const req = store.add(record);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function deleteBook(id) {
      const tx = db.transaction(BOOK_STORE, "readwrite");
      const store = tx.objectStore(BOOK_STORE);
      return new Promise((resolve, reject) => {
        const req = store.delete(Number(id));
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function getBookById(id) {
      const tx = db.transaction(BOOK_STORE, "readonly");
      const store = tx.objectStore(BOOK_STORE);
      return new Promise((resolve, reject) => {
        const req = store.get(Number(id));
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    async function moveBookToFolder(bookId) {
      const shelves = await getShelves();
      const folders = await getAllFolders();
      if (!folders || folders.length === 0) {
        alert("No folders found. Create a folder first.");
        return;
      }
      const choices = folders
        .map((f) => {
          const shelf = shelves.find((s) => s.id === f.shelfId);
          return `${f.id}: ${shelf ? shelf.name : "?"} / ${f.name}`;
        })
        .join("\n");
      const input = prompt(
        "Move to which folder?\n(Type folder ID)\n\n" + choices
      );
      if (!input) return;
      const folderId = Number(input);
      if (Number.isNaN(folderId)) {
        alert("Invalid folder ID.");
        return;
      }
      const targetFolder = folders.find((f) => f.id === folderId);
      if (!targetFolder) {
        alert("Folder not found.");
        return;
      }
      const tx = db.transaction(BOOK_STORE, "readwrite");
      const store = tx.objectStore(BOOK_STORE);
      const book = await new Promise((resolve, reject) => {
        const req = store.get(Number(bookId));
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
      if (!book) return;
      book.folderId = folderId;
      await new Promise((resolve, reject) => {
        const req = store.put(book);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
      await renderBooks();
    }

    /* ---------- UI HELPERS ---------- */

    function formatBytes(bytes) {
      if (!bytes && bytes !== 0) return "";
      const kb = bytes / 1024;
      if (kb < 1024) return kb.toFixed(1) + " KB";
      return (kb / 1024).toFixed(2) + " MB";
    }

    function formatDate(ts) {
      if (!ts) return "";
      const d = new Date(ts);
      return d.toLocaleDateString() + " " + d.toLocaleTimeString();
    }

    /* ---------- RENDER SHELVES ---------- */

    async function renderShelves() {
      const shelfList = document.getElementById("shelf-list");
      shelfList.innerHTML = "";
      const shelves = await getShelves();

      const allItem = document.createElement("div");
      allItem.className =
        "shelf-item" + (currentShelfId === "all" ? " active" : "");
      allItem.textContent = "All Books";
      allItem.onclick = () => {
        currentShelfId = "all";
        currentFolderId = "all";
        renderShelves();
        renderFolders();
        renderBooks();
      };
      shelfList.appendChild(allItem);

      shelves.forEach((shelf) => {
        const item = document.createElement("div");
        item.className =
          "shelf-item" + (currentShelfId === shelf.id ? " active" : "");
        item.dataset.shelfId = shelf.id;

        item.innerHTML = `
          <span class="shelf-name">${shelf.name}</span>
          <button class="shelf-menu-btn" type="button" data-shelf-id="${shelf.id}">â‹¯</button>
        `;

        item.addEventListener("click", () => {
          currentShelfId = shelf.id;
          currentFolderId = "all";
          renderShelves();
          renderFolders();
          renderBooks();
        });

        shelfList.appendChild(item);
      });

      const menuButtons = shelfList.querySelectorAll(".shelf-menu-btn");
      menuButtons.forEach((btn) => {
        btn.addEventListener("click", (event) => {
          event.stopPropagation();
          const shelfId = Number(btn.dataset.shelfId);
          openShelfMenu(shelfId, btn);
        });
      });
    }

    /* ---------- RENDER FOLDERS ---------- */

    async function renderFolders() {
      const chipsEl = document.getElementById("folder-chips");
      const shelfLabel = document.getElementById("current-shelf-label");
      const folderLabel = document.getElementById("current-folder-label");
      chipsEl.innerHTML = "";

      if (currentShelfId === "all") {
        shelfLabel.textContent = "Shelf: All Books";
        folderLabel.textContent = "Folder: All Folders";
        const msg = document.createElement("div");
        msg.className = "folder-empty-msg";
        msg.textContent = "Select a shelf to view its folders.";
        chipsEl.appendChild(msg);
        return;
      }

      const shelves = await getShelves();
      const thisShelf = shelves.find((s) => s.id === currentShelfId);
      shelfLabel.textContent = "Shelf: " + (thisShelf ? thisShelf.name : "Unknown");

      const folders = await getFoldersForShelf(currentShelfId);

      const allChip = document.createElement("button");
      allChip.className =
        "folder-chip" + (currentFolderId === "all" ? " active" : "");
      allChip.textContent = "All folders";
      allChip.onclick = () => {
        currentFolderId = "all";
        renderFolders();
        renderBooks();
      };
      chipsEl.appendChild(allChip);

      folders.forEach((folder) => {
        const wrapper = document.createElement("div");
        wrapper.className = "folder-chip-wrapper";

        const chip = document.createElement("button");
        chip.className =
          "folder-chip" + (currentFolderId === folder.id ? " active" : "");
        chip.textContent = folder.name;
        chip.onclick = () => {
          currentFolderId = folder.id;
          renderFolders();
          renderBooks();
        };

        const menuBtn = document.createElement("button");
        menuBtn.className = "folder-chip-menu-btn";
        menuBtn.textContent = "â‹¯";
        menuBtn.onclick = (event) => {
          event.stopPropagation();
          openFolderMenu(folder.id, menuBtn);
        };

        wrapper.appendChild(chip);
        wrapper.appendChild(menuBtn);
        chipsEl.appendChild(wrapper);
      });

      if (currentFolderId === "all") {
        folderLabel.textContent = "Folder: All Folders";
      } else {
        const currentFolder = folders.find((f) => f.id === currentFolderId);
        folderLabel.textContent =
          "Folder: " + (currentFolder ? currentFolder.name : "Unknown");
      }
    }

    /* ---------- BOOKS FOR CURRENT VIEW ---------- */

    async function getBooksForCurrentView() {
      const books = await getAllBooks();
      if (currentShelfId === "all") return books;

      const folders = await getFoldersForShelf(currentShelfId);
      const folderIds = new Set(folders.map((f) => f.id));

      if (currentFolderId === "all") {
        return books.filter((b) => folderIds.has(b.folderId));
      } else {
        return books.filter((b) => b.folderId === currentFolderId);
      }
    }

    /* ---------- RENDER BOOKS ---------- */

    async function renderBooks() {
      const listEl = document.getElementById("book-list");
      const emptyEl = document.getElementById("library-empty-state");
      listEl.innerHTML = "";

      const books = await getBooksForCurrentView();
      if (!books || books.length === 0) {
        emptyEl.style.display = "block";
        return;
      }
      emptyEl.style.display = "none";

      books
        .sort((a, b) => b.addedAt - a.addedAt)
        .forEach((book) => {
          const row = document.createElement("div");
          row.className = "book-row";

          const meta = document.createElement("div");
          meta.className = "book-meta";
          meta.innerHTML = `
            <div class="book-title">${book.name}</div>
            <div class="book-sub">
              ${formatBytes(book.size)} Â· Added ${formatDate(book.addedAt)}
            </div>
          `;

          const actions = document.createElement("div");
          actions.className = "book-actions";

          const openBtn = document.createElement("button");
          openBtn.className = "small-btn";
          openBtn.textContent = "Open";
          openBtn.onclick = async () => {
            const fullBook = await getBookById(book.id);
            if (!fullBook || !fullBook.fileBlob) return;
            const url = URL.createObjectURL(fullBook.fileBlob);
            window.open(url, "_blank");
          };
          actions.appendChild(openBtn);

          const moveBtn = document.createElement("button");
          moveBtn.className = "small-btn";
          moveBtn.textContent = "Move";
          moveBtn.onclick = () => {
            moveBookToFolder(book.id);
          };
          actions.appendChild(moveBtn);

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "small-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.onclick = async () => {
            if (confirm("Remove this PDF from library?")) {
              await deleteBook(book.id);
              renderBooks();
            }
          };
          actions.appendChild(deleteBtn);

          row.appendChild(meta);
          row.appendChild(actions);
          listEl.appendChild(row);
        });
    }

    /* ---------- SHELF MENU ---------- */

    let shelfMenuEl = null;
    let shelfMenuShelfId = null;

    function setupShelfMenu() {
      shelfMenuEl = document.getElementById("shelf-menu");
      if (!shelfMenuEl) return;

      shelfMenuEl.addEventListener("click", async (event) => {
        const action = event.target.dataset.action;
        if (!action || shelfMenuShelfId == null) return;

        if (action === "organise") {
          const shelves = await getShelves();
          const shelf = shelves.find((s) => s.id === shelfMenuShelfId);
          const newName = prompt(
            "Rename shelf:",
            shelf ? shelf.name : "Untitled"
          );
          if (newName && newName.trim()) {
            await renameShelf(shelfMenuShelfId, newName.trim());
            await renderShelves();
            await renderFolders();
          }
        } else if (action === "delete") {
          const ok = confirm(
            "Delete this shelf and all its folders and PDFs?"
          );
          if (ok) {
            await deleteShelfAndContents(shelfMenuShelfId);
            if (currentShelfId === shelfMenuShelfId) {
              currentShelfId = "all";
              currentFolderId = "all";
            }
            await renderShelves();
            await renderFolders();
            await renderBooks();
          }
        }

        hideShelfMenu();
      });

      document.addEventListener("click", (event) => {
        if (!shelfMenuEl.classList.contains("visible")) return;
        if (!shelfMenuEl.contains(event.target)) {
          hideShelfMenu();
        }
      });
    }

    function openShelfMenu(shelfId, anchorEl) {
      if (!shelfMenuEl) return;
      shelfMenuShelfId = shelfId;
      const pageInner = document.querySelector(".page-inner");
      if (!pageInner) return;
      const rect = anchorEl.getBoundingClientRect();
      const containerRect = pageInner.getBoundingClientRect();
      const top = rect.bottom - containerRect.top + 4;
      const left = rect.right - containerRect.left - 120;
      shelfMenuEl.style.top = `${top}px`;
      shelfMenuEl.style.left = `${left}px`;
      shelfMenuEl.classList.add("visible");
    }

    function hideShelfMenu() {
      if (!shelfMenuEl) return;
      shelfMenuEl.classList.remove("visible");
      shelfMenuShelfId = null;
    }

    /* ---------- FOLDER MENU ---------- */

    let folderMenuEl = null;
    let folderMenuFolderId = null;

    function setupFolderChipMenu() {
      folderMenuEl = document.getElementById("folder-menu");
      if (!folderMenuEl) return;

      folderMenuEl.addEventListener("click", async (event) => {
        const action = event.target.dataset.action;
        if (!action || folderMenuFolderId == null) return;

        if (action === "rename") {
          const folders = await getFoldersForShelf(currentShelfId);
          const folder = folders.find(f => f.id === folderMenuFolderId);
          const newName = prompt(
            "Rename folder:",
            folder ? folder.name : "Untitled"
          );
          if (newName && newName.trim()) {
            await renameFolder(folderMenuFolderId, newName.trim());
            await renderFolders();
          }
        } else if (action === "delete") {
          const ok = confirm("Delete this folder and all PDFs inside?");
          if (ok) {
            await deleteFolderAndBooks(folderMenuFolderId);
            if (currentFolderId === folderMenuFolderId) {
              currentFolderId = "all";
            }
            await renderFolders();
            await renderBooks();
          }
        }

        hideFolderMenu();
      });

      document.addEventListener("click", (event) => {
        if (!folderMenuEl.classList.contains("visible")) return;
        if (!folderMenuEl.contains(event.target)) {
          hideFolderMenu();
        }
      });
    }

    function openFolderMenu(folderId, anchorEl) {
      if (!folderMenuEl) return;
      folderMenuFolderId = folderId;

      const pageInner = document.querySelector(".page-inner");
      if (!pageInner) return;
      const rect = anchorEl.getBoundingClientRect();
      const containerRect = pageInner.getBoundingClientRect();
      const top = rect.bottom - containerRect.top + 4;
      const left = rect.right - containerRect.left - 120;

      folderMenuEl.style.top = `${top}px`;
      folderMenuEl.style.left = `${left}px`;
      folderMenuEl.classList.add("visible");
    }

    function hideFolderMenu() {
      if (!folderMenuEl) return;
      folderMenuEl.classList.remove("visible");
      folderMenuFolderId = null;
    }

    /* ---------- EVENTS ---------- */

    async function onAddShelfClick() {
      const name = prompt("Enter new shelf name:");
      if (!name || !name.trim()) return;
      await addShelf(name.trim());
      await renderShelves();
    }

    async function onAddFolderClick() {
      if (currentShelfId === "all") {
        alert("Select a shelf first, then add a folder inside it.");
        return;
      }
      const name = prompt("Enter new folder name:");
      if (!name || !name.trim()) return;
      await addFolder(name.trim(), currentShelfId);
      await renderFolders();
    }

    async function onAddPdfFiles(event) {
      const files = Array.from(event.target.files || []);
      if (!files.length) return;

      if (currentShelfId === "all" || currentFolderId === "all") {
        alert("Select a specific shelf and folder before adding PDFs.");
        event.target.value = "";
        return;
      }

      for (const file of files) {
        if (file.type !== "application/pdf") continue;
        await addBookRecord(file, currentFolderId);
      }

      event.target.value = "";
      renderBooks();
    }

    async function initLibrary() {
      try {
        db = await openLibraryDB();
        await ensureDefaultShelfAndFolder();
        await renderShelves();
        await renderFolders();
        await renderBooks();
        setupShelfMenu();
        setupFolderChipMenu();
      } catch (err) {
        console.error("Error opening library DB:", err);
      }

      document
        .getElementById("add-shelf-btn")
        .addEventListener("click", onAddShelfClick);

      document
        .getElementById("add-folder-btn")
        .addEventListener("click", onAddFolderClick);

      document
        .getElementById("add-book-btn")
        .addEventListener("click", () => {
          document.getElementById("add-pdf-input").click();
        });

      document
        .getElementById("add-pdf-input")
        .addEventListener("change", onAddPdfFiles);
    }

    document.addEventListener("DOMContentLoaded", initLibrary);
  </script>


</body>
</html>
